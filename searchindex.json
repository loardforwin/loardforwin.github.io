{"categories":[{"title":"学习","uri":"https://loardforwin.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"posts":[{"content":"1.创建表(create) /* 创建数据表: 关键字 create table 格式: create table 表名( 列名1 数据类型[长度] [约束], 列名2 数据类型[长度] [约束], 列名3 数据类型[长度] [约束] ); 细节: 可以使用关键字作为名字,但是为了规范,避开关键字 使用关键字作为名字,请你添加反引号 ``\t'' \u0026quot;\u0026quot; 创建学生信息表 编号,姓名,年龄 */ CREATE TABLE student( id INT, NAME VARCHAR(10), age INT ); #需求：创建雇员表，包含雇员的姓名，密码，性别, 生日信息。 CREATE TABLE employee( NAME VARCHAR(50), PASSWORD VARCHAR(50), gender CHAR(1), birthday DATE ); show create table employee;  2.修改表结构(modify)(添加列，修改列的数据类型，换列名，换表名） /* 在已经创建好的数据表中，修改其表的结构 操作具有风险性（数据丢失） 关键字 alter table */ -- 数据表添加列 列明desc 可变字符255//反引号不能省略 -- alter table 表明 add 列名 数据类型[长度][约束] alter table student add `desc` varchar(255); -- 修改列的数据类型desc列，修改为int -- alter table 表明 modify 列名 新数据类型[长度][约束] alter table student modify `desc` int; -- 修改列名 desc列名改为description -- alter table 表名 change 旧列名 新列名 新数据类型[长度][约束] alter table student change `desc` `description` int; -- 修改表明student修改为student_table -- rename table 旧表名 to新表名 -- 修改出问题了先不要慌,等一会表就会更改了 rename table student_table to student;  3.向表中插入数据(insert)(有三种方式) /* 数据表添加数据C 关键字 insert into values */ -- 添加数据的格式1： -- insert[into] 表名(列名1，列名2，列名3)values(值1，值2，值3) -- 数据库中，值的引号问题，数字可以不写任何符号，其他数据类型加引号，单引号 insert into student(id,name,age,description)values(1,'张三',20,'学习努力'); -- 添加数据的格式2： -- insert[into] 表名 values(全部的值) insert into student values(2,'李四',21,'不好好学习'); select * from student; -- 添加数据的格式3：批量数据 -- insert[into] 表名 values(全部的值),(全部的值),(全部的值) insert into student values (3,'王五',24,'还是可以'), (4,'赵六',12,'太难太难'), (5,'可怕',21,'play game')  4.更新表的数据(update) /* 更新数据 对原有数据进行修改 对没有确定，改了就是改了 关键字 update set where 注意： 修改数据一定要进行条件的筛选 没有条件筛选，表中的所有数据，都会修改 */ -- update 表名 set 列=值，列=值，列=值 where 条件 -- 修改王五，名字，年龄，描述 update student set name='王五五',age=22,description='一般般' where id=3; select * from student; select * from student;  5.删除表的数据(两种方式，delete和truncate区别) /* 删除数据 关键字 delete from 删除数据必须添加条件，否则全部删除 */ delete from student where id=5; -- 删除全部数据 -- delete from student; -- 删表并建表，删除数据的同时连同约束一起 -- truncate student;  6.表的数据约束(主键约束的三种方式，constraint约束区,联合主键) /* 约束：限制 数据表的数据，不能随意，需要做到限制 主键约束 primary key 约束内容： 被设置为主键约束的列，数据在表中具有唯一性 这个主键列的数据，不能是空（null） 每个表只能设置一个主键，每个数据表都应该有一个主键 */ -- 创建主键约束的方式1：创建表的同时，直接创建 -- 结尾的分号可加可不加 create table persons( id int primary key, firstname varchar(50), lastname varchar(50), address varchar(50) ); insert into persons(id,firstname,lastname,address)values(1,'利库','第三方','北京'); -- 主键约束不为空，切不能重复 -- 创建主键约束的方式2：在创建表的约束区域创建//约束区：所有字段与最后);之间的区域就叫做约束区，用来写约束内容 -- 关键字 (约束的英文)constraint ,可以指定约束的名字 约束字母缩写_列名 drop table persons; create table persons( id int, firstname varchar(50), lastname varchar(50), address varchar(50), constraint primary key pk_id (id) ); -- 创建主键约束的方式3：先建好表，修改alter table drop table persons; create table persons( id int, firstname varchar(50), lastname varchar(50), address varchar(50) ); alter table persons add constraint PRIMARY KEY pk_id (id); -- 联合主键，多个列一起，实现一个主键 drop table persons; create table persons( id int, firstname varchar(50), lastname varchar(50), address varchar(50), constraint primary key pk_id (firstname,lastname) );  7.表的数据自增长(auto_increment) /* 数据的自动增长列(免维护) 设置为自动增长列： 必须是整数 必须是主键 关键字：auto_increment */ drop table persons; create table persons( id int primary key auto_increment, firstname varchar(50), lastname varchar(50), address varchar(50) ); insert into persons(firstname,lastname,address)values('刘','德华','香港'); insert into persons(firstname,lastname,address)values('123','德华','香港'); -- 添加语句，可以简化书写//相对于有自增的内容 -- 主键列，写值是null,自动增长 insert into persons values(null,'xc','cc','dd'); -- 删除主键是3的数据 -- 用delete删除表数据表自增长用过的数据就不会再用了 delete from persons; delete from persons where id=3; -- 自增长用过的数据就不会再用了 insert into persons values(null,'ss','dd','ff'); -- 如果用truncate删除表数据，再加表数据的时候，自增长会重置为1//含义：truncate删除表连表约束都一起删了 truncate persons; insert into persons values(null,'ss','dd','ff');  8.表的非空约束（not null） /* 非空约束： 约束的是这个列数据不能是null */ drop table persons; create table persons( id int primary key auto_increment, firstname varchar(50) not null, lastname varchar(50), address varchar(50) ); insert into persons values(null,'郭','ss','dd'); -- 下面程序是错误的，写不进去 insert into persons values(null,null,'ss','dd'); -- 下面程序是可以的null！='' insert into persons values(null,'','ss','dd'); insert into persons(id,lastname,address) values(3,'dd','dd');//有点问题，要提前写好默认值才能用 -- 创建非空约束的方式2：修改表结构 alter table drop table persons; create table persons( id int primary key auto_increment, firstname varchar(50), lastname varchar(50), address varchar(50) ); alter table persons modify firstname varchar(255) not null; -- 删除非空约束 alter table persons modify firstname varchar(255);  9.表唯一约束(unique,三种方法，删除约束) /* 唯一约束： 设置唯一约束的这个列，数据必须唯一性 主键约束也具有唯一性 唯一约束也具有唯一性 主键约束，数据不能是真实的业务数据 手机号，能不能作为主键 //不能 原因：快速注册 关键字 unique */ drop table persons; -- 创建唯一约束的方式1：创建表的同时，直接创建 create table persons( id int primary key auto_increment, firstname varchar(50) unique, lastname varchar(50), address varchar(50) ); insert into persons values(null,'z','s','d'); -- 数据添加失败，唯一约束 insert into persons values(null,'z','sxx','dxx'); -- 非空约束对null值没有影响可以持续加入约束条件为null的数据 insert into persons values(null,null,'sxx','dxx'); insert into persons values(null,null,'sxx','dxx'); -- 非空约束对''值的持续加入是不允许的 insert into persons values(null,'','sxx','dxx'); insert into persons values(null,'','sxx','dxx'); -- 创建唯一约束的方式2：constraint区域添加 drop table persons; create table persons( id int primary key auto_increment, firstname varchar(50), lastname varchar(50), address varchar(50), constraint unique qk_firstname(firstname) ); -- 创建唯一约束的方式3：修改表结构alter table drop table persons; create table persons( id int primary key auto_increment, firstname varchar(50), lastname varchar(50), address varchar(50) ); alter table persons modify firstname varchar(255) unique; insert into persons values(null,'z','s','d'); -- 数据添加失败，唯一约束 insert into persons values(null,'z','sxx','dxx'); -- 删除唯一约束 /* 添加唯一约束后：数据库mysql认为，这个列会经常被查询 会为这个列自动添加 索引(提高数据查询效率) 删除的是这个索引 */ -- 约束名没有定义就是列名，如下firstname，如果定义了那就是定义名 alter table persons drop index firstname;  10.表的默认约束（default） /* 默认约束： 对一个列，数据默认 关键字 default */ -- 创建默认约束方式1：创建表直接添加 drop table persons; create table persons( id int primary key auto_increment, firstname varchar(50), lastname varchar(50), address varchar(50) default '北京市' ); insert into persons value(null,'x','d',null);//默认值加入无效 insert into persons(firstname,lastname) value('dd','ss');//默认值有效 -- 创建默认约束方式2：修改表结构 alter table persons modify address varchar(255) default '天津市';  准备工作  /* c001家电 c002服装 c003化妆品 c004食品 c005饮料 */ #创建商品表： create table product( pid int primary key, \u0026ndash; 名称 pname varchar(20), \u0026ndash; 价格 price double, \u0026ndash; 分类 category_id varchar(32) ); INSERT INTO product(pid,pname,price,category_id) VALUES(1,\u0026lsquo;联想\u0026rsquo;,5000,\u0026lsquo;c001\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(2,\u0026lsquo;海尔\u0026rsquo;,3000,\u0026lsquo;c001\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(3,\u0026lsquo;雷神\u0026rsquo;,5000,\u0026lsquo;c001\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(4,\u0026lsquo;JACK JONES\u0026rsquo;,800,\u0026lsquo;c002\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(5,\u0026lsquo;真维斯\u0026rsquo;,200,\u0026lsquo;c002\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(6,\u0026lsquo;花花公子\u0026rsquo;,440,\u0026lsquo;c002\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(7,\u0026lsquo;劲霸\u0026rsquo;,2000,\u0026lsquo;c002\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(8,\u0026lsquo;香奈儿\u0026rsquo;,800,\u0026lsquo;c003\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(9,\u0026lsquo;相宜本草\u0026rsquo;,200,\u0026lsquo;c003\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(10,\u0026lsquo;面霸\u0026rsquo;,5,\u0026lsquo;c003\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(11,\u0026lsquo;好想你枣\u0026rsquo;,56,\u0026lsquo;c004\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(12,\u0026lsquo;香飘飘奶茶\u0026rsquo;,1,\u0026lsquo;c005\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(13,\u0026lsquo;果9\u0026rsquo;,1,NULL);\n 11.表的数据查询（模糊查询）(select、from、where、as、 distinct（去重）) 11.1表查询的顺序 select 6\nfrom 1\nwhere 2\ngroup by 3\nhaving 4\norder by 5\n/* 数据的基本查询 拼接语句 关键字 select 选择，查询 from 来自哪里，哪个表 where 条件 as 重命名 distinct 去重 基本语法： select (列名，列名) from 查询指定的列 select * from 表名 查询所有列 -- *上班一般不会用，效率低 */ -- 查询数据表，显示商品名和价格 select pname,price from product; -- 查询全部的商品数据 select * from product; -- 查询数据表，查询价格，去掉重复的,基本查询一列 select distinct(price) from product; -- 查询数据表，所有的商品价格上调100元； -- 下面的相关操作都可以 select pname,price+100 as 价格 from product; select pname,price+100 as '价格' from product; select pname,price+100 as price from product; select pname,price+100 as 'price' from product; select pname,price+100 价格 from product; select pname,price+100 price from product; #查询商品名称为“花花公子”的商品所有信息： select * from product where pname='花花公子'; #查询价格为800商品 select * from product where price=800; #查询价格不是800的所有商品 select * from product where price!=800; select * from product where price\u0026lt;\u0026gt;800; select * from product where not(price=800); #查询商品价格大于60元的所有商品信息 select * from product where price\u0026gt;60; #查询商品价格在200到1000之间所有商品 -- between前面的值一定要小于后面的值 select * from product where price between 200 and 1000; select * from product where price\u0026gt;=200 and price\u0026lt;=1000; #查询商品价格是200或800的所有商品 select * from product where price in(200,800); select * from product where price=200 or price=800; # LIKe 中的 %代表匹配任意长度的任意字符; _代表匹配一个任意字符 #查询商品名称含有'霸'字的所有商品 select * from product where pname like '%霸%'; #查询商品名称以'香'开头的所有商品 select * from product where pname like '香%'; #查询商品名称第二个字为'想'的所有商品 select * from product where pname like '_想%'; #商品没有分类id的商品 select * from product where category_id is null; #查询有分类id的商品 select * from product where category_id is not null;  12.表的排序查询(order by asc/desc) /* 排序查询： 对查询的结果集排序 关键字 order by 升序：asc 默认的，可以不写 降序：desc 排序写再sql语句的最后 */ #使用价格排序(降序) select * from product order by price desc; #在价格排序(降序)的基础上，以分类排序(降序) select * from product order by price desc,category_id desc; #显示商品的价格(去重复)，并排序(降序) select distinct(price) from product order by price desc;  13.表的聚合函数（sum、min、max、avg、count） /* 聚合函数 sum(列名) 列的所有值求和 min(列名)\t查询列中的最小值 max(列名)\t查询列中的最大值 avg(列名)\t查询列中的平均值/列数，求和 count(列名) 统计该列共有多少条数据 */ #查询商品的总条数 -- 不推荐 select count(*) from product; -- 推荐 select count(pid) from product; select count(category_id) from product; #查询价格大于200商品的总条数 select count(*) from product where price\u0026gt;200; #查询所有商品的价格总和 select sum(price) from product; #查询分类为'c001'的所有商品的价格总和 select sum(price) from product where category_id='c001'; #查询分类为'c002'所有商品的平均价格 select avg(price) from product where category_id='c002'; #查询商品的最大价格和最小价格 select max(price),min(price) from product;  14.表的分组查询(group by、having) /* 分组查询 举例： 80人，分成10个组，每个组8人 统计数组，每个小组统计 1组：成绩100 2组：成绩99 一个列的相同值，井行分组 关键字 group by 列名 */ -- 按照商品分类进行价格的求和 select sum(price),category_id from product group by category_id; -- 需求追加，不想看到求和后价格低于1000的 -- 在分组求和后的数据基础之上，再次条件过滤 -- where条件过滤在表中过滤(真实的数据表) -- 查询后的结果，过滤条件，使用关键字having select sum(price) price,category_id from product group by category_id having price\u0026gt;1000; # 统计各个分类商品的个数 select pname,count(pname) from product group by pname; # 统计各个分类商品的个数,且只显示个数大于1的信息 -- group by创建的虚拟表不能用where只能用having select category_id,count(category_id) count from product group by category_id having count\u0026gt;1; # 统计价格\u0026gt;200元的 各个分类商品的个数,且只显示个数大于1的信息 select category_id,count(category_id) count from product where price\u0026gt;200 group by category_id having count\u0026gt;1;  15.表的限制查询(limit) /* 限制条数查询 关键字 limit (sql语句的最末尾) 语法：limit m,n m:数据表的开始索引0开始 n:限制显示多少条 mysql默认显示1000条 */ select * from product limit 1,10; select * from product;  tips（计算分页索引值，求分页数） /* 索引=（当前页数-1）*每页条数 知道总页数(n)，每页有m条,求有多少页? 向上取整 Math.ceil(n/m)=总共有多少页 */  ","id":0,"section":"posts","summary":"1.创建表(create) /* 创建数据表: 关键字 create table 格式: create table 表名( 列名1 数据类型[长度] [约束], 列名2 数据类型[长度] [约束], 列名3 数据","tags":["随笔","学习小结"],"title":"MySQL基础语法","uri":"https://loardforwin.github.io/2020/08/mysql%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","year":"2020"},{"content":"注意：[]表示内容可变\nMySQL数据库相关命令  所有命令需要加分号（ ；）\n  创建数据库： create database [数据库名]; 删除数据库： drop database [数据库名]; 设置已存在数据库编码集：alter database [数据库名] character set [utf8]; 显现所有数据库：show databases; 用数据库：use [数据库名]; 查看表结构：desc [表明]；  Navicat快捷语法   快速运行（没选中就是运行全部，有选中了的就是运行选中了的）：Ctrl+R\n  快速选中当前行：\n  光标在行尾：shift+home\n  光标在行前：shift+end\n    F6打开一个mysql命令行窗口\n 打开命令行如果显示数据出现乱码可以设置编码内容，操作如下  set names \u0026lsquo;[字符集]'//可以为utf8或者gbk等      迅速返回sql语句代码顶端：Ctrl+home\n  迅速返回sql语句代码底端：Ctrl+end\n  ","id":1,"section":"posts","summary":"注意：[]表示内容可变 MySQL数据库相关命令 所有命令需要加分号（ ；） 创建数据库： create database [数据库名]; 删除数据库： drop database [数据库名]; 设置已存在","tags":["随笔","学习小结"],"title":"MySQL数据库和Navicat快捷语法","uri":"https://loardforwin.github.io/2020/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8Cnavicat%E5%BF%AB%E6%8D%B7%E8%AF%AD%E6%B3%95/","year":"2020"},{"content":"类的加载器 ClassLoader ——————运行class，加载到内存，方法区\n 加载器用IO流对象将class文件加载到内存\n三个加载器都是CLassLoader的子类\n类的加载器特性：双亲委派，谁用谁加载\n​\t先传给App的双亲，如果加载则停止App,否则最后传回App自己执行\n 1. 引导类加载器 BootClassLoader ​\t负责加载JDK中的核心类库（JDK安装目录，jre/lib/rt.jar）\n2. 扩展类加载器 ExtClassLoader ExtClassLoader extends URLClassLoader\n​\t负责加载JDK的扩展类库（JDK安装目录，jre/lib/ext/*）\n​\tDNSNameService属于JDK 的扩展类库 sun.misc.Launcher$ExtClassLoader@677327b6\nClassLoader classLoader = DNSNameService.class.getClassLoader; System.out.println(classLoader)；  //结果 sun.misc.Launcher$ExtClassLoader@677327b6  3. 应用类加载器 AppClassLoader AppClassLoader extends URLClassLoader\n​\t加载的是我们自己写的类（负责加载第三方jar包，commonsIO等）sun.misc.Launcher$AppClassLoader@18b4aac2\n  可能出现的问题，如下  //查看加载器的类型 Eg:String类 ClassLoader classLoader = String.class.getClassLoader; System.out.println(classLoader)；  //结果 null//出现null的情况原因：类的加载器是C++编写的，和Java根本无关，所以看不到它加载器的类型  ","id":2,"section":"posts","summary":"类的加载器 ClassLoader ——————运行class，加载到内存，方法区 加载器用IO流对象将class文件加载到内存 三个加载器都是CLassLoader的","tags":["学习小结"],"title":"类的加载器ClassLoader","uri":"https://loardforwin.github.io/2020/08/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8-classloader/","year":"2020"},{"content":"反射（Reflect） 反射关键对象：class文件对象\n类加载器创建，获取使用\n三种方法：\n​\t1：对象的方法getClass()获取（getClass()定义在Object类）\n​\t2: 使用类的静态属性class获取\n​\t3：Class类静态方法forName()获取（常用：扩展性好）\n暴力反射方法执行方法：Class类类名.getDeclaredConstructor()\n 不建议使用\n 注意:方法后面加s则去除所有构造\nConstructor 构造方法对象\nFiled 成员变量对象(字段)\nMethod 成员方法对象\n 三者共同继承了父类AccessibleObject\n父类方法setAccessible(true) 取消Java运行时期的安全检查\n在暴力反射后使用\n 随笔  properties文件建立在src文件下\n  项目开发完毕，交给用户使用，是编译后的class文件\nsrc源代码，编译后产生class文件，是同步的\n  如何读取src文件，使用类的加载器\nClassLoader 类定义方法\n​\tInputStream getResourceAsStream(\u0026ldquo;文件名\u0026rdquo;) 返回字节输入流\n​\t此流会自动从类目录下扫描文件读取\n public class Test{ //Test的类加载器，必须先获取到这个类的class文件对象 ClassLoader loader=Test.class.getClassLoader(); //System.out.println(loader);//Launcher$AppClassLoader@18b4aac2 //加载器获取字节输入流 InputStream inputStream=loader.getResourceAsStream(\u0026quot;config.properties\u0026quot;); System.out.println(inputStream); //流对象和集合关联使用 Properties properties=new Properties(); properties.load(inputStream); inputStream.close(); System.out.println(properties); //集合方法，获取值 String className=properties.getProperty(\u0026quot;className\u0026quot;); String methodName=properties.getProperty(\u0026quot;methodName\u0026quot;); //反射，获取这个类的class文件对象 Class c=Class.forName(className); //创建对象 Object object=c.newInstance(); //获取方法 Method method=c.getMethod(methodName); //运行方法 method.invoke(object);  config.properties文件内容\nclassName=XXX methodName=XXX  ","id":3,"section":"posts","summary":"反射（Reflect） 反射关键对象：class文件对象 类加载器创建，获取使用 三种方法： ​ 1：对象的方法getClass()获取（getCla","tags":["随笔","学习小结"],"title":"反射","uri":"https://loardforwin.github.io/2020/08/%E5%8F%8D%E5%B0%84/","year":"2020"},{"content":"我的第一篇博客——博客相关命令 1.创建博客 1.hugo new posts/FileName.md\n2.hugo server -t pure \u0026ndash;buildDrafts //测试静态博客\n3.cd daydream\n4.hugo server -t pure \u0026ndash;buildDrafts\n5.hugo \u0026ndash;theme=pure \u0026ndash;baseUrl=\u0026quot;https://loardforwin.github.io\u0026rdquo; \u0026ndash;buildDrafts\n6.cd public\n7.git add .\n8.git commit -m \u0026ldquo;这是我的博客\u0026rdquo;\n9.cd..\n10.git remote add origin https://github.com/loardforwin/loardforwin.github.io.git\n11.git push -u origin master\n2.博客的更新 1.hugo \u0026ndash;theme=pure \u0026ndash;baseUrl=\u0026quot;https://loardforwin.github.io\u0026rdquo; \u0026ndash;buildDrafts\n2.cd public\n3.git add .\n4.git commit -m \u0026ldquo;这是我的博客\u0026rdquo;\n5.git push -u origin master\n3.创建博客的md文件 1.hugo new xxx.md\n 头文件上的标识\n分类 categories: [\u0026ldquo;xxx\u0026rdquo;,\u0026ldquo;xxx\u0026rdquo;]\n标签 tags: [\u0026ldquo;xxx\u0026rdquo;,\u0026ldquo;xxx\u0026rdquo;]\n描述 description: \u0026ldquo;xxxxxx\u0026rdquo;\n ","id":4,"section":"posts","summary":"我的第一篇博客——博客相关命令 1.创建博客 1.hugo new posts/FileName.md 2.hugo server -t pure \u0026ndash;buildDrafts //测试静态博客 3.cd daydream 4.hugo server -t pure \u0026ndash;buildDrafts 5.hugo \u0026ndash;theme=pure \u0026ndash;baseUrl=\u0026quot;https://loardforwin.github.io\u0026rdquo; \u0026ndash;buildDrafts 6.cd public 7.git add . 8.git commit -m \u0026ldquo;这是我的博客\u0026","tags":["hogo博客命令"],"title":"我的第一篇博客——博客相关命令","uri":"https://loardforwin.github.io/2020/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E5%8D%9A%E5%AE%A2%E5%91%BD%E4%BB%A4/","year":"2020"}],"tags":[{"title":"about","uri":"https://loardforwin.github.io/tags/about/"},{"title":"hogo博客命令","uri":"https://loardforwin.github.io/tags/hogo%E5%8D%9A%E5%AE%A2%E5%91%BD%E4%BB%A4/"},{"title":"学习小结","uri":"https://loardforwin.github.io/tags/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"},{"title":"随笔","uri":"https://loardforwin.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}