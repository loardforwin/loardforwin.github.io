{"categories":[{"title":"学习","uri":"https://loardforwin.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"posts":[{"content":"多表查询新建数据库数据 /* 多表查询 新建的数据库 */ # 分类表 CREATE TABLE category ( cid VARCHAR(32) PRIMARY KEY , cname VARCHAR(50) ); #商品表 CREATE TABLE products( pid VARCHAR(32) PRIMARY KEY , pname VARCHAR(50), price INT, flag VARCHAR(2), #是否上架标记为：1表示上架、0表示下架 category_id VARCHAR(32), CONSTRAINT products_category_fk FOREIGN KEY (category_id) REFERENCES category (cid) ); #分类 INSERT INTO category(cid,cname) VALUES('c001','家电'); INSERT INTO category(cid,cname) VALUES('c002','服饰'); INSERT INTO category(cid,cname) VALUES('c003','化妆品'); #商品 INSERT INTO products(pid, pname,price,flag,category_id) VALUES('p001','联想',5000,'1','c001'); INSERT INTO products(pid, pname,price,flag,category_id) VALUES('p002','海尔',3000,'1','c001'); INSERT INTO products(pid, pname,price,flag,category_id) VALUES('p003','雷神',5000,'1','c001'); INSERT INTO products (pid, pname,price,flag,category_id) VALUES('p004','JACK JONES',800,'1','c002'); INSERT INTO products (pid, pname,price,flag,category_id) VALUES('p005','真维斯',200,'1','c002'); INSERT INTO products (pid, pname,price,flag,category_id) VALUES('p006','花花公子',440,'1','c002'); INSERT INTO products (pid, pname,price,flag,category_id) VALUES('p007','劲霸',2000,'1','c002'); INSERT INTO products (pid, pname,price,flag,category_id) VALUES('p008','香奈儿',800,'1','c003'); INSERT INTO products (pid, pname,price,flag,category_id) VALUES('p009','相宜本草',200,'1','c003'); /* 多表数据查询 同时查询分类和商品表 语法： select 列名 from 表名1，表名2 */ -- 查表生成的是笛卡尔积 select * from category,products;  随笔   navicat中 utf8_general_ci选项是大小写不敏感的意思\n  数据表主外键（约束）的添加是针对数据的插入而言的，为数据插入做的限定\n  但由select * from A，B可知会出现笛卡尔积(两表的乘积)的数据表，从而出现了多表查询的约束条件\n 如下\n    1.内连接查询 1.1隐式内连接 /* 查询语法： select 列名 from 表A，表B where条件 主表的主键=从表的外键 */ select * from category,products where cid=category_id; /* 加入，主表的主键和从表的外键的列名，相同 表名，列名 */ select * from category,products where category.cid=products.category_id; /* 推荐：可以使用as重命名 */ select * from category c,products p where c.cid=p.category_id;  1.2显示内连接 /* 内链接：显示内连接 关键字 inner join 条件过滤,关键字不用where 用 on */ select * from category c inner join products p on c.cid=p.category_id; /* 外链接查询： 左外：left outer join 参照点就是左边的表！！左表的数据必须都显示，右表数据没有，显示null 右外：right outer join 参照点就是右边的表！！右表的数据必须都显示，左表没有相关数据，则不能显示 --一般主表写前面，从表写右边 */ select * from category c left outer join products p on c.cid=p.category_id; select * from category c right outer join products p on c.cid=p.category_id;  2.子查询 /* 子查询： 两个查询放在一起，一个是子，一个是父 子查询的结果，可以让另一个查询来使用 可以作为条件，也可以作为另一个表 */ -- 需求1：查询归属于化妆品的商品 select * from products where category_id='c003'; /* 分析：在分类表中，查询这个c003再使用 */ select * from category where cname='化妆品'; select * from products where category_id=(select cid from category where cname='化妆品'); -- 需求2：查询归属于化妆品的商品 select * from products p,(select * from category where cname='化妆品') c where p.category_id=c.cid; /* 使用子查询，同时查询出商品是服装和化妆品 查询的条件使用子查询来实现 */ -- 原版 select * from products where category_id ='c002' or category_id='c003'; select * from category where cname='化妆品' or cname='服饰'; -- 用子查询的版本 select * from products where category_id in (select cid from category where cname='化妆品' or cname='服饰');  3.索引(创建索引，查看索引，删除索引) /* 索引 index 海量数据的年代 MySQL数据库，查询数据的时候，全部数据到扫描，超出你要的数据 索引技术，提升查询效率 MySQL数据的存储引擎：数据在硬盘的存储方式(文件 010101) btree是索引类型 InnoDB(主流)：文件 支持事务 支持关系，主外键 数据增删改慢，查询一般 MYISAM：文件 不支持事务 不支持关系，主外键 数据增删改，快，查询一般 Memory：存储在内存中，关机，丢失 1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引 2） 唯一索引 ：索引列的值必须唯一，但允许有空值 约束，唯一约束unique，自动创建索引 3） 复合索引 ：即一个索引包含多个列 */ -- 价格上创建索引 create index index_price on products(price); -- 查看表中索引 show index from products; -- 删除索引 drop index index_price on products;  ","id":0,"section":"posts","summary":"多表查询新建数据库数据 /* 多表查询 新建的数据库 */ # 分类表 CREATE TABLE category ( cid VARCHAR(32) PRIMARY KEY , cname VARCHAR(50) ); #商品表 CREATE TABLE products( pid VARCHAR(32) PRIMARY KEY , pname VARCHAR(50), price INT, flag VARCHAR(2), #是否上架标记为：1表示上","tags":["随笔","学习小结"],"title":"多表查询","uri":"https://loardforwin.github.io/2020/08/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/","year":"2020"},{"content":"1.创建主外键关系 /* 创建主外键关系 */ create table category( cid int primary key auto_increment, cname varchar(32) ); #商品表 create table product( pid int primary key auto_increment, pname varchar(32), price int, category_id int ); /* 创建外键约束,外键约束外键约束，顾名思义就是用外键约束自己 下面的例子中category（cid）是product(category_id)的外键，则product的数据变化是随着category的变化而变化的 语法： alter table 从表名 add constraint foreign key[约束名] （从表的外键的列名） references 主表名(主键列名) */ alter table product add constraint foreign key fk_category_id (category_id) references category(cid); -- 商品分类表添加测试数据 insert into category VALUES(null,'家电'); insert into category VALUES(null,'服装'); -- 商品信息表添加测试数据，注意category_id列的数据，参照主表的主键编写 insert into product values(null,'联想笔记本',5999,1); insert into product values(null,'花花公子',59,2); -- 添加测试失败的数据 -- 主表中没有的数据，从表中添加失败 insert into product values(null,'饼干',99,3); /* 创建订单表orders 主键，订单总金额 */ create table orders( oid int primary key auto_increment, total int ); -- 订单表添加测试数据 -- 1号订单，联想，jack insert into orders values(null,6199); -- 2订单，联想，雷神，jack insert into orders values(null,12199); /* 商品和订单是多对多关系，中间表，表示关系 2个列，都是外键，一个关联商品主键，一个关联订单主键 */ create table ordersitem( pid int, oid int ); /* 中间表创建外键约束 中间表的pid列外键，主键是商品表pid */ alter table ordersitem add constraint foreign key fk_pid (pid) references product(pid); /* 中间表创建外键约束 中间表的oid列外键，主键是订单表oid */ alter table ordersitem add constraint foreign key fk_oid (oid) references orders(oid); /* 中间表添加数据 1号订单，联想，jack */ insert into ordersitem values(1,1); insert into ordersitem values(6,1); /* 中间表添加数据 2订单，联想，雷神，jack */ insert into ordersitem values(1,2); insert into ordersitem values(4,2); insert into ordersitem values(6,2);  2.一对多的关系 省份表\n   主键 名字     1 北京市   2 河北省   3 辽宁省    城市表\n   主键 城市名字 外键     1 昌平区 1   2 海淀区 1   3 廊坊市 2   4 保定市 2   5 石家庄 2   6 沈阳市 3   7 葫芦岛 3    /* 一对多联系 省和市 */ -- 创建省份表，主键，名字 create table province( pid int primary key auto_increment, pname varchar(20) ); -- 创建城市表，名字，外键 create table city( cid int primary key auto_increment, cname varchar(20), pid INT ); -- 城市表添加外键约束，外键是pid，主键是省份表的pid alter table city add constraint foreign key fk_city_pid (pid) references province(pid); -- 省份表添加测试数据 insert into province values(null,'北京市'),(null,'河北省'),(null,'辽宁省'); -- 城市表添加数据，参考省份表的主键！ insert into city values(null,'昌平区',1),(null,'海淀区',1),(null,'朝阳区',1); insert into city values(null,'石家庄',2),(null,'保定市',2); insert into city values(null,'沈阳市',3),(null,'葫芦岛市',3); -- 创建错误数据 insert into city values(null,'武汉市',4); /* 报错信息： insert into city values(null,'武汉市',4) \u0026gt; 1452 - Cannot add or update a child row: a foreign key constraint fails 》》\u0026gt; 》\u0026gt;\u0026gt;\u0026gt; \u0026gt; (`mydatabase`.`city`, CONSTRAINT `city_ibfk_1` FOREIGN KEY (`pid`) REFERENCES `province` (`pid`)) \u0026gt; 时间: 0.016s \u0026gt; */  3.多对多关系（需要中间表） /* 用户名和角色：多对多 */ -- 用户表 create table `user` ( uid varchar(32) PRIMARY KEY, username varchar(32) ); -- 角色表 create table role ( rid varchar(32) PRIMARY KEY, rname varchar(32) ); -- 中间表 create table user_role( user_id varchar(32), role_id varchar(32), CONSTRAINT user_role_pk PRIMARY KEY(user_id,role_id), CONSTRAINT user_id_fk FOREIGN KEY(user_id) REFERENCES `user`(uid), CONSTRAINT role_id_fk FOREIGN KEY(role_id) REFERENCES role(rid) ); -- 中间表添加数据 insert into user_role values(1,2); insert into user_role values(1,1); insert into user_role values(2,1); insert into user_role values(2,2);  ","id":1,"section":"posts","summary":"1.创建主外键关系 /* 创建主外键关系 */ create table category( cid int primary key auto_increment, cname varchar(32) ); #商品表 create table product( pid int primary key auto_increment, pname varchar(32), price int, category_id int ); /* 创建外键约束,外键约束外键约束，顾名思义就","tags":["学习小结"],"title":"表的关系","uri":"https://loardforwin.github.io/2020/08/%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB/","year":"2020"},{"content":"1.创建表(create) /* 创建数据表: 关键字 create table 格式: create table 表名( 列名1 数据类型[长度] [约束], 列名2 数据类型[长度] [约束], 列名3 数据类型[长度] [约束] ); 细节: 可以使用关键字作为名字,但是为了规范,避开关键字 使用关键字作为名字,请你添加反引号 ``\t'' \u0026quot;\u0026quot; 创建学生信息表 编号,姓名,年龄 */ CREATE TABLE student( id INT, NAME VARCHAR(10), age INT ); #需求：创建雇员表，包含雇员的姓名，密码，性别, 生日信息。 CREATE TABLE employee( NAME VARCHAR(50), PASSWORD VARCHAR(50), gender CHAR(1), birthday DATE ); show create table employee;  2.修改表结构(modify)(添加列，修改列的数据类型，换列名，换表名） /* 在已经创建好的数据表中，修改其表的结构 操作具有风险性（数据丢失） 关键字 alter table */ -- 数据表添加列 列明desc 可变字符255//反引号不能省略 -- alter table 表明 add 列名 数据类型[长度][约束] alter table student add `desc` varchar(255); -- 修改列的数据类型desc列，修改为int -- alter table 表明 modify 列名 新数据类型[长度][约束] alter table student modify `desc` int; -- 修改列名 desc列名改为description -- alter table 表名 change 旧列名 新列名 新数据类型[长度][约束] alter table student change `desc` `description` int; -- 修改表明student修改为student_table -- rename table 旧表名 to新表名 -- 修改出问题了先不要慌,等一会表就会更改了 rename table student_table to student;  3.向表中插入数据(insert)(有三种方式) /* 数据表添加数据C 关键字 insert into values */ -- 添加数据的格式1： -- insert[into] 表名(列名1，列名2，列名3)values(值1，值2，值3) -- 数据库中，值的引号问题，数字可以不写任何符号，其他数据类型加引号，单引号 insert into student(id,name,age,description)values(1,'张三',20,'学习努力'); -- 添加数据的格式2： -- insert[into] 表名 values(全部的值) insert into student values(2,'李四',21,'不好好学习'); select * from student; -- 添加数据的格式3：批量数据 -- insert[into] 表名 values(全部的值),(全部的值),(全部的值) insert into student values (3,'王五',24,'还是可以'), (4,'赵六',12,'太难太难'), (5,'可怕',21,'play game')  4.更新表的数据(update) /* 更新数据 对原有数据进行修改 对没有确定，改了就是改了 关键字 update set where 注意： 修改数据一定要进行条件的筛选 没有条件筛选，表中的所有数据，都会修改 */ -- update 表名 set 列=值，列=值，列=值 where 条件 -- 修改王五，名字，年龄，描述 update student set name='王五五',age=22,description='一般般' where id=3; select * from student; select * from student;  5.删除表的数据(两种方式，delete和truncate区别) /* 删除数据 关键字 delete from 删除数据必须添加条件，否则全部删除 */ delete from student where id=5; -- 删除全部数据 -- delete from student; -- 删表并建表，删除数据的同时连同约束一起 -- truncate student;  6.表的数据约束(主键约束的三种方式，constraint约束区,联合主键) /* 约束：限制 数据表的数据，不能随意，需要做到限制 主键约束 primary key 约束内容： 被设置为主键约束的列，数据在表中具有唯一性 这个主键列的数据，不能是空（null） 每个表只能设置一个主键，每个数据表都应该有一个主键 */ -- 创建主键约束的方式1：创建表的同时，直接创建 -- 结尾的分号可加可不加 create table persons( id int primary key, firstname varchar(50), lastname varchar(50), address varchar(50) ); insert into persons(id,firstname,lastname,address)values(1,'利库','第三方','北京'); -- 主键约束不为空，切不能重复 -- 创建主键约束的方式2：在创建表的约束区域创建//约束区：所有字段与最后);之间的区域就叫做约束区，用来写约束内容 -- 关键字 (约束的英文)constraint ,可以指定约束的名字 约束字母缩写_列名 drop table persons; create table persons( id int, firstname varchar(50), lastname varchar(50), address varchar(50), constraint primary key pk_id (id) ); -- 创建主键约束的方式3：先建好表，修改alter table drop table persons; create table persons( id int, firstname varchar(50), lastname varchar(50), address varchar(50) ); alter table persons add constraint PRIMARY KEY pk_id (id); -- 联合主键，多个列一起，实现一个主键 drop table persons; create table persons( id int, firstname varchar(50), lastname varchar(50), address varchar(50), constraint primary key pk_id (firstname,lastname) );  7.表的数据自增长(auto_increment) /* 数据的自动增长列(免维护) 设置为自动增长列： 必须是整数 必须是主键 关键字：auto_increment */ drop table persons; create table persons( id int primary key auto_increment, firstname varchar(50), lastname varchar(50), address varchar(50) ); insert into persons(firstname,lastname,address)values('刘','德华','香港'); insert into persons(firstname,lastname,address)values('123','德华','香港'); -- 添加语句，可以简化书写//相对于有自增的内容 -- 主键列，写值是null,自动增长 insert into persons values(null,'xc','cc','dd'); -- 删除主键是3的数据 -- 用delete删除表数据表自增长用过的数据就不会再用了 delete from persons; delete from persons where id=3; -- 自增长用过的数据就不会再用了 insert into persons values(null,'ss','dd','ff'); -- 如果用truncate删除表数据，再加表数据的时候，自增长会重置为1//含义：truncate删除表连表约束都一起删了 truncate persons; insert into persons values(null,'ss','dd','ff');  8.表的非空约束（not null） /* 非空约束： 约束的是这个列数据不能是null */ drop table persons; create table persons( id int primary key auto_increment, firstname varchar(50) not null, lastname varchar(50), address varchar(50) ); insert into persons values(null,'郭','ss','dd'); -- 下面程序是错误的，写不进去 insert into persons values(null,null,'ss','dd'); -- 下面程序是可以的null！='' insert into persons values(null,'','ss','dd'); insert into persons(id,lastname,address) values(3,'dd','dd');//有点问题，要提前写好默认值才能用 -- 创建非空约束的方式2：修改表结构 alter table drop table persons; create table persons( id int primary key auto_increment, firstname varchar(50), lastname varchar(50), address varchar(50) ); alter table persons modify firstname varchar(255) not null; -- 删除非空约束 alter table persons modify firstname varchar(255);  9.表唯一约束(unique,三种方法，删除约束) /* 唯一约束： 设置唯一约束的这个列，数据必须唯一性 主键约束也具有唯一性 唯一约束也具有唯一性 主键约束，数据不能是真实的业务数据 手机号，能不能作为主键 //不能 原因：快速注册 关键字 unique */ drop table persons; -- 创建唯一约束的方式1：创建表的同时，直接创建 create table persons( id int primary key auto_increment, firstname varchar(50) unique, lastname varchar(50), address varchar(50) ); insert into persons values(null,'z','s','d'); -- 数据添加失败，唯一约束 insert into persons values(null,'z','sxx','dxx'); -- 非空约束对null值没有影响可以持续加入约束条件为null的数据 insert into persons values(null,null,'sxx','dxx'); insert into persons values(null,null,'sxx','dxx'); -- 非空约束对''值的持续加入是不允许的 insert into persons values(null,'','sxx','dxx'); insert into persons values(null,'','sxx','dxx'); -- 创建唯一约束的方式2：constraint区域添加 drop table persons; create table persons( id int primary key auto_increment, firstname varchar(50), lastname varchar(50), address varchar(50), constraint unique qk_firstname(firstname) ); -- 创建唯一约束的方式3：修改表结构alter table drop table persons; create table persons( id int primary key auto_increment, firstname varchar(50), lastname varchar(50), address varchar(50) ); alter table persons modify firstname varchar(255) unique; insert into persons values(null,'z','s','d'); -- 数据添加失败，唯一约束 insert into persons values(null,'z','sxx','dxx'); -- 删除唯一约束 /* 添加唯一约束后：数据库mysql认为，这个列会经常被查询 会为这个列自动添加 索引(提高数据查询效率) 删除的是这个索引 */ -- 约束名没有定义就是列名，如下firstname，如果定义了那就是定义名 alter table persons drop index firstname;  10.表的默认约束（default） /* 默认约束： 对一个列，数据默认 关键字 default */ -- 创建默认约束方式1：创建表直接添加 drop table persons; create table persons( id int primary key auto_increment, firstname varchar(50), lastname varchar(50), address varchar(50) default '北京市' ); insert into persons value(null,'x','d',null);//默认值加入无效 insert into persons(firstname,lastname) value('dd','ss');//默认值有效 -- 创建默认约束方式2：修改表结构 alter table persons modify address varchar(255) default '天津市';  准备工作  /* c001家电 c002服装 c003化妆品 c004食品 c005饮料 */ #创建商品表： create table product( pid int primary key, \u0026ndash; 名称 pname varchar(20), \u0026ndash; 价格 price double, \u0026ndash; 分类 category_id varchar(32) ); INSERT INTO product(pid,pname,price,category_id) VALUES(1,\u0026lsquo;联想\u0026rsquo;,5000,\u0026lsquo;c001\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(2,\u0026lsquo;海尔\u0026rsquo;,3000,\u0026lsquo;c001\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(3,\u0026lsquo;雷神\u0026rsquo;,5000,\u0026lsquo;c001\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(4,\u0026lsquo;JACK JONES\u0026rsquo;,800,\u0026lsquo;c002\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(5,\u0026lsquo;真维斯\u0026rsquo;,200,\u0026lsquo;c002\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(6,\u0026lsquo;花花公子\u0026rsquo;,440,\u0026lsquo;c002\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(7,\u0026lsquo;劲霸\u0026rsquo;,2000,\u0026lsquo;c002\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(8,\u0026lsquo;香奈儿\u0026rsquo;,800,\u0026lsquo;c003\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(9,\u0026lsquo;相宜本草\u0026rsquo;,200,\u0026lsquo;c003\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(10,\u0026lsquo;面霸\u0026rsquo;,5,\u0026lsquo;c003\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(11,\u0026lsquo;好想你枣\u0026rsquo;,56,\u0026lsquo;c004\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(12,\u0026lsquo;香飘飘奶茶\u0026rsquo;,1,\u0026lsquo;c005\u0026rsquo;); INSERT INTO product(pid,pname,price,category_id) VALUES(13,\u0026lsquo;果9\u0026rsquo;,1,NULL);\n 11.表的数据查询（模糊查询）(select、from、where、as、 distinct（去重）) 11.1表查询的顺序 select 6\nfrom 1\nwhere 2\ngroup by 3\nhaving 4\norder by 5\n/* 数据的基本查询 拼接语句 关键字 select 选择，查询 from 来自哪里，哪个表 where 条件 as 重命名 distinct 去重 基本语法： select (列名，列名) from 查询指定的列 select * from 表名 查询所有列 -- *上班一般不会用，效率低 */ -- 查询数据表，显示商品名和价格 select pname,price from product; -- 查询全部的商品数据 select * from product; -- 查询数据表，查询价格，去掉重复的,基本查询一列 select distinct(price) from product; -- 查询数据表，所有的商品价格上调100元； -- 下面的相关操作都可以 select pname,price+100 as 价格 from product; select pname,price+100 as '价格' from product; select pname,price+100 as price from product; select pname,price+100 as 'price' from product; select pname,price+100 价格 from product; select pname,price+100 price from product; #查询商品名称为“花花公子”的商品所有信息： select * from product where pname='花花公子'; #查询价格为800商品 select * from product where price=800; #查询价格不是800的所有商品 select * from product where price!=800; select * from product where price\u0026lt;\u0026gt;800; select * from product where not(price=800); #查询商品价格大于60元的所有商品信息 select * from product where price\u0026gt;60; #查询商品价格在200到1000之间所有商品 -- between前面的值一定要小于后面的值 select * from product where price between 200 and 1000; select * from product where price\u0026gt;=200 and price\u0026lt;=1000; #查询商品价格是200或800的所有商品 select * from product where price in(200,800); select * from product where price=200 or price=800; # LIKe 中的 %代表匹配任意长度的任意字符; _代表匹配一个任意字符 #查询商品名称含有'霸'字的所有商品 select * from product where pname like '%霸%'; #查询商品名称以'香'开头的所有商品 select * from product where pname like '香%'; #查询商品名称第二个字为'想'的所有商品 select * from product where pname like '_想%'; #商品没有分类id的商品 select * from product where category_id is null; #查询有分类id的商品 select * from product where category_id is not null;  12.表的排序查询(order by asc/desc) /* 排序查询： 对查询的结果集排序 关键字 order by 升序：asc 默认的，可以不写 降序：desc 排序写再sql语句的最后 */ #使用价格排序(降序) select * from product order by price desc; #在价格排序(降序)的基础上，以分类排序(降序) select * from product order by price desc,category_id desc; #显示商品的价格(去重复)，并排序(降序) select distinct(price) from product order by price desc;  13.表的聚合函数（sum、min、max、avg、count） /* 聚合函数 sum(列名) 列的所有值求和 min(列名)\t查询列中的最小值 max(列名)\t查询列中的最大值 avg(列名)\t查询列中的平均值/列数，求和 count(列名) 统计该列共有多少条数据 */ #查询商品的总条数 -- 不推荐 select count(*) from product; -- 推荐 select count(pid) from product; select count(category_id) from product; #查询价格大于200商品的总条数 select count(*) from product where price\u0026gt;200; #查询所有商品的价格总和 select sum(price) from product; #查询分类为'c001'的所有商品的价格总和 select sum(price) from product where category_id='c001'; #查询分类为'c002'所有商品的平均价格 select avg(price) from product where category_id='c002'; #查询商品的最大价格和最小价格 select max(price),min(price) from product;  14.表的分组查询(group by、having) /* 分组查询 举例： 80人，分成10个组，每个组8人 统计数组，每个小组统计 1组：成绩100 2组：成绩99 一个列的相同值，井行分组 关键字 group by 列名 */ -- 按照商品分类进行价格的求和 select sum(price),category_id from product group by category_id; -- 需求追加，不想看到求和后价格低于1000的 -- 在分组求和后的数据基础之上，再次条件过滤 -- where条件过滤在表中过滤(真实的数据表) -- 查询后的结果，过滤条件，使用关键字having select sum(price) price,category_id from product group by category_id having price\u0026gt;1000; # 统计各个分类商品的个数 select pname,count(pname) from product group by pname; # 统计各个分类商品的个数,且只显示个数大于1的信息 -- group by创建的虚拟表不能用where只能用having select category_id,count(category_id) count from product group by category_id having count\u0026gt;1; # 统计价格\u0026gt;200元的 各个分类商品的个数,且只显示个数大于1的信息 select category_id,count(category_id) count from product where price\u0026gt;200 group by category_id having count\u0026gt;1;  15.表的限制查询(limit) /* 限制条数查询 关键字 limit (sql语句的最末尾) 语法：limit m,n m:数据表的开始索引0开始 n:限制显示多少条 mysql默认显示1000条 */ select * from product limit 1,10; select * from product;  tips（计算分页索引值，求分页数） /* 索引=（当前页数-1）*每页条数 知道总页数(n)，每页有m条,求有多少页? 向上取整 Math.ceil(n/m)=总共有多少页 */  ","id":2,"section":"posts","summary":"1.创建表(create) /* 创建数据表: 关键字 create table 格式: create table 表名( 列名1 数据类型[长度] [约束], 列名2 数据类型[长度] [约束], 列名3 数据","tags":["随笔","学习小结"],"title":"MySQL基础语法","uri":"https://loardforwin.github.io/2020/08/mysql%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","year":"2020"},{"content":"注意：[]表示内容可变\nMySQL数据库相关命令  所有命令需要加分号（ ；）\n  创建数据库： create database [数据库名]; 删除数据库： drop database [数据库名]; 设置已存在数据库编码集：alter database [数据库名] character set [utf8]; 显现所有数据库：show databases; 用数据库：use [数据库名]; 查看表结构：desc [表明]；  Navicat快捷语法   快速运行（没选中就是运行全部，有选中了的就是运行选中了的）：Ctrl+R\n  快速选中当前行：\n  光标在行尾：shift+home\n  光标在行前：shift+end\n    F6打开一个mysql命令行窗口\n 打开命令行如果显示数据出现乱码可以设置编码内容，操作如下  set names \u0026lsquo;[字符集]'//可以为utf8或者gbk等      迅速返回sql语句代码顶端：Ctrl+home\n  迅速返回sql语句代码底端：Ctrl+end\n  ","id":3,"section":"posts","summary":"注意：[]表示内容可变 MySQL数据库相关命令 所有命令需要加分号（ ；） 创建数据库： create database [数据库名]; 删除数据库： drop database [数据库名]; 设置已存在","tags":["随笔","学习小结"],"title":"MySQL数据库和Navicat快捷语法","uri":"https://loardforwin.github.io/2020/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8Cnavicat%E5%BF%AB%E6%8D%B7%E8%AF%AD%E6%B3%95/","year":"2020"},{"content":"类的加载器 ClassLoader ——————运行class，加载到内存，方法区\n 加载器用IO流对象将class文件加载到内存\n三个加载器都是CLassLoader的子类\n类的加载器特性：双亲委派，谁用谁加载\n​\t先传给App的双亲，如果加载则停止App,否则最后传回App自己执行\n 1. 引导类加载器 BootClassLoader ​\t负责加载JDK中的核心类库（JDK安装目录，jre/lib/rt.jar）\n2. 扩展类加载器 ExtClassLoader ExtClassLoader extends URLClassLoader\n​\t负责加载JDK的扩展类库（JDK安装目录，jre/lib/ext/*）\n​\tDNSNameService属于JDK 的扩展类库 sun.misc.Launcher$ExtClassLoader@677327b6\nClassLoader classLoader = DNSNameService.class.getClassLoader; System.out.println(classLoader)；  //结果 sun.misc.Launcher$ExtClassLoader@677327b6  3. 应用类加载器 AppClassLoader AppClassLoader extends URLClassLoader\n​\t加载的是我们自己写的类（负责加载第三方jar包，commonsIO等）sun.misc.Launcher$AppClassLoader@18b4aac2\n  可能出现的问题，如下  //查看加载器的类型 Eg:String类 ClassLoader classLoader = String.class.getClassLoader; System.out.println(classLoader)；  //结果 null//出现null的情况原因：类的加载器是C++编写的，和Java根本无关，所以看不到它加载器的类型  ","id":4,"section":"posts","summary":"类的加载器 ClassLoader ——————运行class，加载到内存，方法区 加载器用IO流对象将class文件加载到内存 三个加载器都是CLassLoader的","tags":["学习小结"],"title":"类的加载器ClassLoader","uri":"https://loardforwin.github.io/2020/08/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8-classloader/","year":"2020"},{"content":"反射（Reflect） 反射关键对象：class文件对象\n类加载器创建，获取使用\n三种方法：\n​\t1：对象的方法getClass()获取（getClass()定义在Object类）\n​\t2: 使用类的静态属性class获取\n​\t3：Class类静态方法forName()获取（常用：扩展性好）\n暴力反射方法执行方法：Class类类名.getDeclaredConstructor()\n 不建议使用\n 注意:方法后面加s则去除所有构造\nConstructor 构造方法对象\nFiled 成员变量对象(字段)\nMethod 成员方法对象\n 三者共同继承了父类AccessibleObject\n父类方法setAccessible(true) 取消Java运行时期的安全检查\n在暴力反射后使用\n 随笔  properties文件建立在src文件下\n  项目开发完毕，交给用户使用，是编译后的class文件\nsrc源代码，编译后产生class文件，是同步的\n  如何读取src文件，使用类的加载器\nClassLoader 类定义方法\n​\tInputStream getResourceAsStream(\u0026ldquo;文件名\u0026rdquo;) 返回字节输入流\n​\t此流会自动从类目录下扫描文件读取\n public class Test{ //Test的类加载器，必须先获取到这个类的class文件对象 ClassLoader loader=Test.class.getClassLoader(); //System.out.println(loader);//Launcher$AppClassLoader@18b4aac2 //加载器获取字节输入流 InputStream inputStream=loader.getResourceAsStream(\u0026quot;config.properties\u0026quot;); System.out.println(inputStream); //流对象和集合关联使用 Properties properties=new Properties(); properties.load(inputStream); inputStream.close(); System.out.println(properties); //集合方法，获取值 String className=properties.getProperty(\u0026quot;className\u0026quot;); String methodName=properties.getProperty(\u0026quot;methodName\u0026quot;); //反射，获取这个类的class文件对象 Class c=Class.forName(className); //创建对象 Object object=c.newInstance(); //获取方法 Method method=c.getMethod(methodName); //运行方法 method.invoke(object);  config.properties文件内容\nclassName=XXX methodName=XXX  ","id":5,"section":"posts","summary":"反射（Reflect） 反射关键对象：class文件对象 类加载器创建，获取使用 三种方法： ​ 1：对象的方法getClass()获取（getCla","tags":["随笔","学习小结"],"title":"反射","uri":"https://loardforwin.github.io/2020/08/%E5%8F%8D%E5%B0%84/","year":"2020"},{"content":"我的第一篇博客——博客相关命令 1.创建博客 1.hugo new posts/FileName.md\n2.hugo server -t pure \u0026ndash;buildDrafts //测试静态博客\n3.cd daydream\n4.hugo server -t pure \u0026ndash;buildDrafts\n5.hugo \u0026ndash;theme=pure \u0026ndash;baseUrl=\u0026quot;https://loardforwin.github.io\u0026rdquo; \u0026ndash;buildDrafts\n6.cd public\n7.git add .\n8.git commit -m \u0026ldquo;这是我的博客\u0026rdquo;\n9.cd..\n10.git remote add origin https://github.com/loardforwin/loardforwin.github.io.git\n11.git push -u origin master\n2.博客的更新 1.hugo \u0026ndash;theme=pure \u0026ndash;baseUrl=\u0026quot;https://loardforwin.github.io\u0026rdquo; \u0026ndash;buildDrafts\n2.cd public\n3.git add .\n4.git commit -m \u0026ldquo;这是我的博客\u0026rdquo;\n5.git push -u origin master\n3.创建博客的md文件 1.hugo new xxx.md\n 头文件上的标识\n分类 categories: [\u0026ldquo;xxx\u0026rdquo;,\u0026ldquo;xxx\u0026rdquo;]\n标签 tags: [\u0026ldquo;xxx\u0026rdquo;,\u0026ldquo;xxx\u0026rdquo;]\n描述 description: \u0026ldquo;xxxxxx\u0026rdquo;\n ","id":6,"section":"posts","summary":"我的第一篇博客——博客相关命令 1.创建博客 1.hugo new posts/FileName.md 2.hugo server -t pure \u0026ndash;buildDrafts //测试静态博客 3.cd daydream 4.hugo server -t pure \u0026ndash;buildDrafts 5.hugo \u0026ndash;theme=pure \u0026ndash;baseUrl=\u0026quot;https://loardforwin.github.io\u0026rdquo; \u0026ndash;buildDrafts 6.cd public 7.git add . 8.git commit -m \u0026ldquo;这是我的博客\u0026","tags":["hogo博客命令"],"title":"我的第一篇博客——博客相关命令","uri":"https://loardforwin.github.io/2020/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E5%8D%9A%E5%AE%A2%E5%91%BD%E4%BB%A4/","year":"2020"}],"tags":[{"title":"about","uri":"https://loardforwin.github.io/tags/about/"},{"title":"hogo博客命令","uri":"https://loardforwin.github.io/tags/hogo%E5%8D%9A%E5%AE%A2%E5%91%BD%E4%BB%A4/"},{"title":"学习小结","uri":"https://loardforwin.github.io/tags/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"},{"title":"随笔","uri":"https://loardforwin.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}